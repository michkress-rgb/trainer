<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Trinity Meditation — 3D Tri-Lights</title>
  <style>
    :root{
      --panel-bg: rgba(12, 14, 18, 0.74);
      --panel-stroke: rgba(255,255,255,0.09);
      --text: rgba(255,255,255,0.90);
      --muted: rgba(255,255,255,0.62);
      --shadow: 0 18px 60px rgba(0,0,0,0.58);
      --radius: 16px;
      --soft: rgba(255,255,255,0.06);
      --soft2: rgba(255,255,255,0.03);
    }

    html, body{
      height:100%;
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
    }

    canvas{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      background: radial-gradient(1200px 900px at 50% 55%, rgba(14,18,28,0.96), rgba(7,8,12,1) 60%, rgba(0,0,0,1) 100%);
    }

    .panel{
      position:fixed;
      left:18px;
      bottom:18px;
      width:min(560px, calc(100vw - 36px));
      background:var(--panel-bg);
      border:1px solid var(--panel-stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding:14px 14px 12px 14px;
      z-index:2;
      user-select:none;
    }

    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      margin-bottom:10px;
    }

    .titleBlock{ display:flex; flex-direction:column; gap:4px; }
    .title{
      font-weight:700;
      font-size:14px;
      letter-spacing:0.2px;
      color:rgba(255,255,255,0.93);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      letter-spacing:0.2px;
      line-height:1.25;
      max-width: 54ch;
    }

    .btnSmall{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.86);
      font-size:12px;
      letter-spacing:0.2px;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      flex: 0 0 auto;
      white-space:nowrap;
    }
    .btnSmall:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.16); }
    .btnSmall:active{ transform: translateY(0px); }

    .grid{ display:grid; grid-template-columns:1fr; gap:10px; }

    .control{
      padding:10px 10px 8px 10px;
      border-radius:12px;
      border:1px solid var(--soft);
      background: var(--soft2);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    label{
      font-size:12px;
      color:rgba(255,255,255,0.84);
      letter-spacing:0.25px;
    }
    .val{
      font-variant-numeric: tabular-nums;
      font-size:12px;
      color:rgba(255,255,255,0.74);
      white-space:nowrap;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:14px;
      background:transparent;
      outline:none;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:10px;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.10);
    }
    input[type="range"]::-moz-range-track{
      height:10px;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.10);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      margin-top:-5px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.45));
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      border:1px solid rgba(0,0,0,0.35);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px;
      height:18px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.45));
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      border:1px solid rgba(0,0,0,0.35);
    }

    .toggles{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }

    .switch{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--soft);
      background: var(--soft2);
      flex: 1 1 240px;
      min-width: 220px;
    }
    .switch .meta{ display:flex; flex-direction:column; gap:2px; }
    .switch .meta .small{
      font-size:11px;
      color:rgba(255,255,255,0.60);
      line-height:1.2;
    }

    .checkbox{
      width:42px;
      height:26px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      position:relative;
      flex: 0 0 auto;
      cursor:pointer;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
    }
    .checkbox::after{
      content:"";
      position:absolute;
      top:3px;
      left:3px;
      width:20px;
      height:20px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.40));
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
      transition: transform 160ms ease, opacity 160ms ease;
      opacity:0.92;
    }
    .checkbox.on{
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.18);
    }
    .checkbox.on::after{ transform: translateX(16px); opacity:1; }

    details.about{
      border:1px solid var(--soft);
      background: var(--soft2);
      border-radius:12px;
      padding:10px;
    }
    details.about summary{
      cursor:pointer;
      font-size:12px;
      letter-spacing:0.25px;
      color:rgba(255,255,255,0.84);
      list-style:none;
    }
    details.about summary::-webkit-details-marker{ display:none; }
    .aboutText{
      margin-top:8px;
      font-size:11px;
      color:rgba(255,255,255,0.64);
      line-height:1.35;
    }
    .footer{
      margin-top:10px;
      color:rgba(255,255,255,0.55);
      font-size:11px;
      letter-spacing:0.2px;
      line-height:1.35;
    }

    /* error overlay (only if JS crashes) */
    #errBox{
      position:fixed;
      top:18px;
      right:18px;
      max-width:min(560px, calc(100vw - 36px));
      background: rgba(20, 8, 10, 0.82);
      border: 1px solid rgba(255, 120, 140, 0.25);
      color: rgba(255,255,255,0.92);
      padding:12px 14px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      z-index: 10;
      display:none;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="main"></canvas>

  <div id="errBox"></div>

  <div class="panel" role="group" aria-label="Simulation controls">
    <div class="topbar">
      <div class="titleBlock">
        <div class="title" id="uiTitle"></div>
        <div class="hint" id="uiHint"></div>
      </div>
      <button id="langBtn" class="btnSmall" type="button">DE</button>
    </div>

    <div class="grid">

      <div class="control">
        <div class="row"><label id="lblSpeed" for="speed"></label><div class="val" id="speedVal"></div></div>
        <input id="speed" type="range" min="0" max="3" step="0.001" value="0.80"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblErratic" for="erratic"></label><div class="val" id="erraticVal"></div></div>
        <input id="erratic" type="range" min="0" max="1" step="0.001" value="0.30"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblCourse" for="course"></label><div class="val" id="courseVal"></div></div>
        <input id="course" type="range" min="0" max="1" step="0.001" value="0.55"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblFlux" for="flux"></label><div class="val" id="fluxVal"></div></div>
        <input id="flux" type="range" min="0" max="1" step="0.001" value="0.18"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblLove" for="love"></label><div class="val" id="loveVal"></div></div>
        <input id="love" type="range" min="0" max="1" step="0.001" value="0.25"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblDistinct" for="distinct"></label><div class="val" id="distinctVal"></div></div>
        <input id="distinct" type="range" min="0" max="1" step="0.001" value="0.15"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblSize" for="size"></label><div class="val" id="sizeVal"></div></div>
        <input id="size" type="range" min="0.18" max="0.62" step="0.001" value="0.46"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblDepth" for="depth"></label><div class="val" id="depthVal"></div></div>
        <input id="depth" type="range" min="0.9" max="2.6" step="0.001" value="1.25"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblTrails" for="trails"></label><div class="val" id="trailsVal"></div></div>
        <input id="trails" type="range" min="0" max="1" step="0.001" value="0.55"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblHue" for="hue"></label><div class="val" id="hueVal"></div></div>
        <input id="hue" type="range" min="0" max="360" step="0.1" value="205"/>
      </div>

      <div class="control">
        <div class="row"><label id="lblIntensity" for="intensity"></label><div class="val" id="intensityVal"></div></div>
        <input id="intensity" type="range" min="0" max="1" step="0.001" value="0.82"/>
      </div>

      <div class="toggles">
        <div class="switch">
          <div class="meta">
            <label id="lblCenter"></label>
            <div class="small" id="lblCenterSub"></div>
          </div>
          <div id="centerSwitch" class="checkbox on" role="switch" aria-checked="true" tabindex="0"></div>
        </div>

        <div class="switch">
          <div class="meta">
            <label id="lblStars"></label>
            <div class="small" id="lblStarsSub"></div>
          </div>
          <div id="starsSwitch" class="checkbox" role="switch" aria-checked="false" tabindex="0"></div>
        </div>
      </div>

      <details class="about" open>
        <summary id="aboutSummary"></summary>
        <div class="aboutText" id="aboutText"></div>
      </details>

      <div class="footer" id="footerText"></div>
    </div>
  </div>

<script>
(() => {
  const errBox = document.getElementById("errBox");
  function showErr(e){
    errBox.style.display = "block";
    errBox.textContent =
      "A script error occurred.\n\n" +
      (e && (e.stack || e.message) ? (e.stack || e.message) : String(e)) +
      "\n\nIf you see this, copy the message and send it to me.";
  }

  try {
    // ============================
    // Language strings (EN/DE)
    // ============================
    const STR = {
      en: {
        title: "Trinity Meditation — 3D Tri-Lights",
        hint:
          "This is a symbolic meditation aid only: three lights remain a perfect, inseparable triangle (unity), yet each can be perceived distinctly (relation). It does not depict God; it supports recollection and love.",
        speed: "Spin Speed",
        erratic: "Erratic Motion",
        course: "Course Changes (interval)",
        flux: "Quantum Flux",
        love: "Love Pulse",
        distinct: "Distinct Persons (brightness only)",
        size: "Triangle Size",
        depth: "Camera Depth",
        trails: "Trails",
        hue: "Color (Hue)",
        intensity: "Light Intensity",
        center: "Center Light",
        centerSub: "A small central glow as a unity-anchor (optional)",
        stars: "Starfield",
        starsSub: "Toggle a quiet “heavens” background",
        aboutSummary: "Meditation note (St. Elizabeth of the Trinity)",
        aboutText:
          "St. Elizabeth of the Trinity emphasizes interior recollection and the indwelling Trinity: letting the soul become a place of loving attention. Use this model as a gentle prompt: three lights in one motion (unity), never breaking communion; and yet, three ‘persons’ can be contemplated without collapsing into three separate gods. If it distracts, lower Flux, raise Trails slightly, and slow the Speed.",
        footer:
          "Tip: Start with Speed ~0.6, Intensity ~0.8. Increase Course Changes for clearer ‘turns.’ Use Flux sparingly. Distinct Persons changes only brightness (not color) to preserve a single shared light.",
        unitsDegPerSec: "°/s",
        unitsSec: "s",
        unitsPct: "%",
        langBtn: "DE"
      },
      de: {
        title: "Trinitäts-Meditation — 3D Drei-Lichter",
        hint:
          "Nur eine symbolische Meditationshilfe: drei Lichter bleiben ein vollkommenes, untrennbares Dreieck (Einheit) und sind doch unterscheidbar (Beziehung). Sie stellt Gott nicht dar; sie hilft bei Sammlung und Liebe.",
        speed: "Drehgeschwindigkeit",
        erratic: "Unruhe",
        course: "Kurswechsel (Intervall)",
        flux: "Quanten-Flux",
        love: "Liebes-Puls",
        distinct: "Personen unterscheidbar (nur Helligkeit)",
        size: "Dreiecksgröße",
        depth: "Kameratiefe",
        trails: "Spuren",
        hue: "Farbe (Farbton)",
        intensity: "Lichtintensität",
        center: "Zentrales Licht",
        centerSub: "Kleines Licht im Zentrum als Einheits-Anker (optional)",
        stars: "Sternenfeld",
        starsSub: "Ruhiger „Himmels“-Hintergrund",
        aboutSummary: "Meditationshinweis (Hl. Elisabeth von der Dreifaltigkeit)",
        aboutText:
          "Die hl. Elisabeth von der Dreifaltigkeit betont innere Sammlung und die inwohnende Dreifaltigkeit: die Seele als Ort liebender Aufmerksamkeit. Nutze dieses Modell als sanften Anstoß: drei Lichter in einer Bewegung (Einheit), ohne Bruch der Gemeinschaft; und doch drei „Personen“ betrachtbar, ohne in drei Götter zu zerfallen. Wenn es ablenkt: Flux reduzieren, Spuren leicht erhöhen, Geschwindigkeit senken.",
        footer:
          "Tipp: Beginne mit Geschwindigkeit ~0,6 und Intensität ~0,8. Kurswechsel erhöhen für deutlichere „Wendungen“. Flux sparsam. „Personen“ verändert nur Helligkeit (nicht Farbe), damit das Licht geteilt bleibt.",
        unitsDegPerSec: "°/s",
        unitsSec: "s",
        unitsPct: "%",
        langBtn: "EN"
      }
    };

    let lang = "en";
    const el = (id) => document.getElementById(id);

    // ============================
    // Canvas setup (visible + offscreen trails)
    // ============================
    const canvas = el("main");
    const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

    const lightCanvas = document.createElement("canvas");
    const lctx = lightCanvas.getContext("2d", { alpha: true, desynchronized: true });

    let W=0, H=0, DPR=1;

    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);

      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      lightCanvas.width = Math.floor(W * DPR);
      lightCanvas.height = Math.floor(H * DPR);
      lctx.setTransform(DPR,0,0,DPR,0,0);

      buildGradient();
      rebuildStars();

      // Hard-clear the light buffer so lights show immediately after reload/resize
      lctx.clearRect(0,0,W,H);
    }
    window.addEventListener("resize", resize, {passive:true});

    // Background gradient cache
    let bgGrad = null;
    function buildGradient(){
      bgGrad = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.05,
                                        W*0.5, H*0.55, Math.max(W,H)*0.75);
      bgGrad.addColorStop(0.00, "rgba(14,18,28,0.95)");
      bgGrad.addColorStop(0.60, "rgba(7,8,12,1.00)");
      bgGrad.addColorStop(1.00, "rgba(0,0,0,1.00)");
    }

    // ============================
    // UI state
    // ============================
    const params = {
      speed: +el("speed").value,
      erratic: +el("erratic").value,
      course: +el("course").value,
      flux: +el("flux").value,
      love: +el("love").value,
      distinct: +el("distinct").value,
      size: +el("size").value,
      depth: +el("depth").value,
      trails: +el("trails").value,
      hue: +el("hue").value,
      intensity: +el("intensity").value,
      centerOn: true,
      starsOn: false
    };

    function bindRange(id, key){
      el(id).addEventListener("input", () => { params[key] = +el(id).value; syncLabels(); }, {passive:true});
    }
    ["speed","erratic","course","flux","love","distinct","size","depth","trails","hue","intensity"].forEach(k => bindRange(k,k));

    function fmt(x,d=2){ return Number(x).toFixed(d); }
    function mix(a,b,t){ return a + (b-a)*t; }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    function syncLabels(){
      const S = STR[lang];
      const degPerSec = (params.speed ** 1.20) * 720;
      el("speedVal").textContent = fmt(degPerSec,0) + " " + S.unitsDegPerSec;

      el("erraticVal").textContent = fmt(params.erratic,2);

      const courseSec = mix(2.8, 0.16, params.course);
      el("courseVal").textContent = fmt(courseSec,2) + " " + S.unitsSec;

      el("fluxVal").textContent = fmt(params.flux,2);
      el("loveVal").textContent = fmt(params.love,2);
      el("distinctVal").textContent = fmt(params.distinct,2);

      el("sizeVal").textContent = fmt(params.size,2);
      el("depthVal").textContent = fmt(params.depth,2);

      el("trailsVal").textContent = fmt(params.trails*100,0) + S.unitsPct;

      el("hueVal").textContent = fmt(params.hue,0) + "°";
      el("intensityVal").textContent = fmt(params.intensity,2);
    }

    function applyLang(){
      const S = STR[lang];
      document.documentElement.lang = (lang === "de") ? "de" : "en";

      el("uiTitle").textContent = S.title;
      el("uiHint").textContent  = S.hint;

      el("lblSpeed").textContent = S.speed;
      el("lblErratic").textContent = S.erratic;
      el("lblCourse").textContent = S.course;
      el("lblFlux").textContent = S.flux;
      el("lblLove").textContent = S.love;
      el("lblDistinct").textContent = S.distinct;
      el("lblSize").textContent = S.size;
      el("lblDepth").textContent = S.depth;
      el("lblTrails").textContent = S.trails;
      el("lblHue").textContent = S.hue;
      el("lblIntensity").textContent = S.intensity;

      el("lblCenter").textContent = S.center;
      el("lblCenterSub").textContent = S.centerSub;

      el("lblStars").textContent = S.stars;
      el("lblStarsSub").textContent = S.starsSub;

      el("aboutSummary").textContent = S.aboutSummary;
      el("aboutText").textContent = S.aboutText;
      el("footerText").textContent = S.footer;

      el("langBtn").textContent = S.langBtn;

      syncLabels();
    }

    el("langBtn").addEventListener("click", () => {
      lang = (lang === "en") ? "de" : "en";
      applyLang();
    });

    // Switches
    const centerSwitch = el("centerSwitch");
    function setCenter(on){
      params.centerOn = on;
      centerSwitch.classList.toggle("on", on);
      centerSwitch.setAttribute("aria-checked", String(on));
    }
    function toggleCenter(){ setCenter(!params.centerOn); }
    centerSwitch.addEventListener("click", toggleCenter);
    centerSwitch.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggleCenter(); }});

    const starsSwitch = el("starsSwitch");
    function setStars(on){
      params.starsOn = on;
      starsSwitch.classList.toggle("on", on);
      starsSwitch.setAttribute("aria-checked", String(on));
    }
    function toggleStars(){ setStars(!params.starsOn); }
    starsSwitch.addEventListener("click", toggleStars);
    starsSwitch.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggleStars(); }});

    // ============================
    // 3D math + quaternions
    // ============================
    const TAU = Math.PI*2;

    const len3 = (v)=>Math.hypot(v.x,v.y,v.z);
    const norm3 = (v)=>{ const l=len3(v)||1; return {x:v.x/l,y:v.y/l,z:v.z/l}; };
    const dot3 = (a,b)=>a.x*b.x + a.y*b.y + a.z*b.z;
    const add3 = (a,b)=>({x:a.x+b.x,y:a.y+b.y,z:a.z+b.z});
    const mul3 = (v,s)=>({x:v.x*s,y:v.y*s,z:v.z*s});

    function expSlew(current, target, lambda, dt){
      const k = 1 - Math.exp(-lambda*dt);
      return current + (target-current)*k;
    }

    function slerpDir(a,b,t){
      const an = norm3(a), bn = norm3(b);
      let c = clamp(dot3(an,bn), -1, 1);
      const ang = Math.acos(c);
      if (ang < 1e-5) return an;
      const s = Math.sin(ang);
      const w1 = Math.sin((1-t)*ang)/s;
      const w2 = Math.sin(t*ang)/s;
      return norm3(add3(mul3(an,w1), mul3(bn,w2)));
    }

    const qNorm = (q)=>{
      const l = Math.hypot(q.w,q.x,q.y,q.z) || 1;
      return {w:q.w/l, x:q.x/l, y:q.y/l, z:q.z/l};
    };
    const qMul = (a,b)=>({
      w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
      x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
      y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
      z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,
    });
    const qFromAxisAngle = (axis, angle)=>{
      const half = angle*0.5;
      const s = Math.sin(half);
      const a = norm3(axis);
      return qNorm({w:Math.cos(half), x:a.x*s, y:a.y*s, z:a.z*s});
    };
    const qRotateVec = (q,v)=>{
      const p = {w:0, x:v.x, y:v.y, z:v.z};
      const qc = {w:q.w, x:-q.x, y:-q.y, z:-q.z};
      const r = qMul(qMul(q,p),qc);
      return {x:r.x, y:r.y, z:r.z};
    };

    // ============================
    // PRNG (deterministic)
    // ============================
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const rand = mulberry32((Date.now() ^ 0x9E3779B9) >>> 0);
    const randRange = (a,b)=>a+(b-a)*rand();

    function randomUnitVector(){
      const u = rand()*2 - 1;
      const t = rand()*TAU;
      const r = Math.sqrt(Math.max(0, 1-u*u));
      return {x:r*Math.cos(t), y:r*Math.sin(t), z:u};
    }

    // ============================
    // Geometry: equilateral triangle vertices (local XY plane)
    // ============================
    function triVerts(side){
      const R = side / Math.sqrt(3);
      return [
        {x: R, y: 0, z: 0},
        {x: R*Math.cos(TAU/3), y: R*Math.sin(TAU/3), z: 0},
        {x: R*Math.cos(2*TAU/3), y: R*Math.sin(2*TAU/3), z: 0},
      ];
    }

    function project(v, camDist, fov){
      const zc = camDist - v.z;
      const s = fov / Math.max(0.001, zc);
      return { x: v.x*s, y: v.y*s, s, z: v.z };
    }

    // ============================
    // Starfield
    // ============================
    let stars = [];
    function rebuildStars(){
      stars = [];
      const count = Math.floor(clamp((W*H)/6500, 140, 650));
      for(let i=0;i<count;i++){
        const d = rand() ** 1.7;
        stars.push({ x: rand(), y: rand(), d, tw: randRange(0.6, 1.6), ph: randRange(0, TAU) });
      }
    }

    function drawStars(now){
      const t = now * 0.00002;
      const dx = 0.020 * Math.sin(t*13.1);
      const dy = 0.018 * Math.cos(t*11.7);

      for(const s of stars){
        const depth = 0.35 + 0.85*s.d;
        const tw = 0.55 + 0.45*Math.sin(s.ph + now*0.0012*s.tw);
        const a = 0.04 + 0.26*depth*tw;

        const x = ((s.x + dx*depth) % 1 + 1) % 1;
        const y = ((s.y + dy*depth) % 1 + 1) % 1;

        const px = x * W;
        const py = y * H;

        const r = 0.6 + 1.8*depth;
        ctx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`;
        ctx.beginPath();
        ctx.arc(px, py, r, 0, TAU);
        ctx.fill();
      }
    }

    // ============================
    // Glow rendering (offscreen light buffer)
    // ============================
    function hsl(h,s,l,a=1){
      return `hsla(${h.toFixed(2)}, ${s.toFixed(2)}%, ${l.toFixed(2)}%, ${a.toFixed(3)})`;
    }

    function fadeLightBuffer(){
      // trails slider: higher -> longer trails -> smaller alpha fade
      const trails = clamp(params.trails, 0, 1);
      const a = mix(0.26, 0.05, trails);  // important: NEVER fully clear by default
      lctx.globalCompositeOperation = "source-over";
      lctx.fillStyle = `rgba(0,0,0,${a.toFixed(3)})`;
      lctx.fillRect(0,0,W,H);
    }

    function drawGlow(x,y,r,hue,intensity,depthScale,isCenter=false){
      const ds = clamp(depthScale, 0.65, 1.8);
      const centerK = isCenter ? 0.62 : 1.00;

      const baseAlpha = (0.18 + 0.70*intensity) * (0.72 + 0.28*ds);
      const hotAlpha  = (0.22 + 0.78*intensity) * (0.68 + 0.32*ds);

      // Outer bloom
      {
        const R = r * (2.6 + 2.2*intensity) * ds * centerK;
        const g = lctx.createRadialGradient(x,y,0,x,y,R);
        g.addColorStop(0.00, hsl(hue,95,70,0.00));
        g.addColorStop(0.10, hsl(hue,95,70,baseAlpha*0.58));
        g.addColorStop(0.45, hsl(hue,95,55,baseAlpha*0.24));
        g.addColorStop(1.00, hsl(hue,95,45,0.00));
        lctx.fillStyle = g;
        lctx.beginPath(); lctx.arc(x,y,R,0,TAU); lctx.fill();
      }
      // Mid glow
      {
        const R = r * (1.25 + 1.50*intensity) * ds * centerK;
        const g = lctx.createRadialGradient(x,y,0,x,y,R);
        g.addColorStop(0.00, hsl(hue,100,74,hotAlpha*0.25));
        g.addColorStop(0.20, hsl(hue,100,68,hotAlpha*0.65));
        g.addColorStop(0.60, hsl(hue,100,55,hotAlpha*0.22));
        g.addColorStop(1.00, hsl(hue,100,50,0.00));
        lctx.fillStyle = g;
        lctx.beginPath(); lctx.arc(x,y,R,0,TAU); lctx.fill();
      }
      // Core
      {
        const R = r * (0.40 + 0.36*intensity) * ds * centerK;
        const g = lctx.createRadialGradient(x,y,0,x,y,R);
        g.addColorStop(0.00, hsl(hue,100,92,0.95));
        g.addColorStop(0.35, hsl(hue,100,82,0.70));
        g.addColorStop(1.00, hsl(hue,100,60,0.00));
        lctx.fillStyle = g;
        lctx.beginPath(); lctx.arc(x,y,R,0,TAU); lctx.fill();
      }
    }

    function vignette(){
      const g = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.05,
                                        W*0.5, H*0.55, Math.max(W,H)*0.75);
      g.addColorStop(0.00, "rgba(0,0,0,0.00)");
      g.addColorStop(0.60, "rgba(0,0,0,0.18)");
      g.addColorStop(1.00, "rgba(0,0,0,0.62)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
    }

    // ============================
    // Motion model: coherent course changes (axis + speed) + flux layer
    // ============================
    let q = {w:1,x:0,y:0,z:0};

    let axisCur = norm3({x: 0.25, y: 0.88, z: 0.40});
    let axisTgt = axisCur;

    let omegaMulCur = 1.0, omegaMulTgt = 1.0;

    let courseTimer = 0;
    let fluxTimer = 0;

    let fluxPulse = 0;
    let fluxPulseTgt = 0;

    let phaseAxisCur = norm3({x:-0.6,y:0.2,z:0.78});
    let phaseAxisTgt = phaseAxisCur;
    let phaseRateCur = 0, phaseRateTgt = 0;

    function chooseCourse(err){
      // Interval-based direction change (no per-frame jitter)
      const dev = 0.05 + 0.92*err;
      axisTgt = slerpDir(axisCur, randomUnitVector(), dev);

      const speedWander = 0.08 + 0.70*err;
      omegaMulTgt = clamp(1.0 + randRange(-1,1)*speedWander, 0.18, 2.8);
    }

    function chooseFluxEvent(err, flux){
      // Rarer, deeper reorientation (still smooth)
      const dev = clamp(0.35 + 0.55*flux + 0.25*err, 0.35, 0.97);
      axisTgt = slerpDir(axisCur, randomUnitVector(), dev);

      fluxPulseTgt = clamp(0.20 + 1.35*flux, 0, 1.8);

      phaseAxisTgt = slerpDir(phaseAxisCur, randomUnitVector(), clamp(0.25 + 0.55*flux, 0, 0.9));
      phaseRateTgt = (0.15 + 2.0*flux) * (rand() < 0.5 ? -1 : 1);
    }

    // ============================
    // Render loop
    // ============================
    let last = performance.now();

    function frame(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      const cx = W*0.5;
      const cy = H*0.52;

      // --- background (fresh each frame; never affected by trails)
      ctx.fillStyle = bgGrad || "#000";
      ctx.fillRect(0,0,W,H);
      if (params.starsOn) drawStars(now);

      // --- trails buffer fade
      fadeLightBuffer();

      // --- geometry
      const side = Math.min(W,H) * clamp(params.size, 0.18, 0.62);
      const local = triVerts(side);

      const e = params.erratic;
      const f = params.flux;

      // --- timing (intervals)
      const baseCourse = mix(2.8, 0.16, params.course);
      const coursePeriod = mix(baseCourse*1.15, baseCourse*0.55, e);
      const fluxPeriod = mix(7.2, 0.55, f);

      courseTimer += dt;
      if (courseTimer >= coursePeriod){
        courseTimer -= coursePeriod;
        chooseCourse(e);
      }

      fluxTimer += dt;
      if (fluxTimer >= fluxPeriod){
        fluxTimer -= fluxPeriod;
        chooseFluxEvent(e, f);
      }

      // --- steer smoothly toward targets
      const steer = mix(2.2, 10.5, e) + 2.2*f;
      axisCur = slerpDir(axisCur, axisTgt, 1 - Math.exp(-steer*dt));
      omegaMulCur = expSlew(omegaMulCur, omegaMulTgt, steer*0.9, dt);

      fluxPulse = expSlew(fluxPulse, fluxPulseTgt, 8.0, dt);
      fluxPulseTgt = expSlew(fluxPulseTgt, 0, 1.8, dt);

      phaseAxisCur = slerpDir(phaseAxisCur, phaseAxisTgt, 1 - Math.exp(-2.8*dt));
      phaseRateCur = expSlew(phaseRateCur, phaseRateTgt, 2.2, dt);
      phaseRateTgt = expSlew(phaseRateTgt, 0, 0.85, dt);

      // --- angular speed (high range, still controllable)
      const baseOmega = (params.speed ** 1.18) * 12.8; // rad/sec
      const fluxBoost = 1.0 + 0.20*f + 0.22*fluxPulse;
      const omega = baseOmega * omegaMulCur * fluxBoost;

      // integrate orientation
      q = qNorm(qMul(qFromAxisAngle(axisCur, omega*dt), q));
      if (f > 0.0005 || Math.abs(phaseRateCur) > 1e-4){
        q = qNorm(qMul(qFromAxisAngle(phaseAxisCur, phaseRateCur*dt), q));
      }

      // --- hue (shared) + subtle breathing
      const hueBreath = 7.0*(0.10 + 0.90*(e+f)/2) * Math.sin(now*0.00035);
      const hue = (params.hue + hueBreath + 360) % 360;

      // --- camera
      const camBase = Math.min(W,H) * clamp(params.depth, 0.9, 2.6);
      const camWob = (0.05 + 0.18*e + 0.12*f) * Math.sin(now*0.00022);
      const camDist = camBase * (1.0 + camWob);
      const fov = Math.min(W,H) * 0.92;

      // --- rotate + project
      const world = local.map(v => qRotateVec(q, v));
      const proj = world.map(v => {
        const p = project(v, camDist, fov);
        return { x: cx + p.x, y: cy + p.y, depthScale: p.s, z: v.z };
      });

      // depth sort back-to-front
      const idx = [0,1,2].sort((i,j)=>proj[i].z - proj[j].z);

      // --- unity edge (subtle)
      lctx.globalCompositeOperation = "source-over";
      lctx.lineWidth = 1.0;
      lctx.strokeStyle = hsl(hue, 90, 60, 0.02 + 0.10*params.intensity);
      lctx.beginPath();
      lctx.moveTo(proj[0].x, proj[0].y);
      lctx.lineTo(proj[1].x, proj[1].y);
      lctx.lineTo(proj[2].x, proj[2].y);
      lctx.closePath();
      lctx.stroke();

      // --- intensity shaping: "love pulse" (shared) + optional distinct brightness offsets
      const lovePulse = 1 + (params.love * 0.28) * Math.sin(now*0.0007 * TAU);

      const d = clamp(params.distinct, 0, 1);
      const t = now*0.0010;
      const phases = [0, TAU/3, 2*TAU/3];
      let mods = phases.map(ph => 1 + d*0.18*Math.sin(t*0.9 + ph));
      // renormalize so average stays ~1 (preserves “one shared light” feel)
      const avg = (mods[0]+mods[1]+mods[2]) / 3;
      mods = mods.map(m => m / (avg || 1));

      // size
      const baseDot = Math.max(4.2, Math.min(10.5, Math.min(W,H)*0.0100));
      const dotR = baseDot * (0.80 + 1.55*params.intensity);

      // --- draw glows (additive)
      lctx.save();
      lctx.globalCompositeOperation = "lighter";

      for (const i of idx){
        const inten = clamp(params.intensity * lovePulse * mods[i], 0, 1.25);
        drawGlow(proj[i].x, proj[i].y, dotR*4.2, hue, inten, proj[i].depthScale, false);
      }

      if (params.centerOn){
        const centerDepth = 1.0 + 0.06*Math.sin(now*0.0011);
        const centerInten = clamp(params.intensity * 0.80 * lovePulse, 0, 1.2);
        drawGlow(cx, cy, dotR*3.2, hue, centerInten, centerDepth, true);
      }

      lctx.restore();

      // --- crisp cores
      lctx.globalCompositeOperation = "source-over";
      lctx.fillStyle = hsl(hue, 100, 92, 0.55 + 0.35*params.intensity);
      for (const i of idx){
        const r = dotR*0.58 * clamp(proj[i].depthScale, 0.75, 1.35);
        lctx.beginPath();
        lctx.arc(proj[i].x, proj[i].y, r, 0, TAU);
        lctx.fill();
      }
      if (params.centerOn){
        lctx.beginPath();
        lctx.arc(cx, cy, dotR*0.42, 0, TAU);
        lctx.fill();
      }

      // --- composite light buffer onto main
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.drawImage(lightCanvas, 0, 0, W, H);
      ctx.restore();

      // --- vignette on top
      vignette();

      requestAnimationFrame(frame);
    }

    // ============================
    // init
    // ============================
    function setSwitch(elm, on){
      elm.classList.toggle("on", on);
      elm.setAttribute("aria-checked", String(on));
    }
    setSwitch(centerSwitch, true);
    setSwitch(starsSwitch, false);

    resize();
    applyLang();
    syncLabels();
    requestAnimationFrame(frame);

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
