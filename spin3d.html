```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>3D Tri-Lights — Course-Changing Motion</title>
  <style>
    :root{
      --panel-bg: rgba(12, 14, 18, 0.72);
      --panel-stroke: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.88);
      --muted: rgba(255,255,255,0.60);
      --shadow: 0 18px 60px rgba(0,0,0,0.55);
      --radius: 16px;
    }
    html, body{
      height:100%;
      margin:0;
      background:#07080c;
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      background: radial-gradient(1200px 900px at 50% 55%, rgba(14,18,28,0.95), rgba(7,8,12,1) 60%, rgba(0,0,0,1) 100%);
    }
    .panel{
      position:fixed;
      left:18px;
      bottom:18px;
      width:min(420px, calc(100vw - 36px));
      background:var(--panel-bg);
      border:1px solid var(--panel-stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding:14px 14px 12px 14px;
    }
    .titleRow{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:8px;
    }
    .title{ font-weight:650; font-size:14px; letter-spacing:0.2px; color:rgba(255,255,255,0.92); }
    .hint{ font-size:12px; color:var(--muted); letter-spacing:0.2px; white-space:nowrap; }
    .grid{ display:grid; grid-template-columns:1fr; gap:10px; }
    .control{
      padding:10px 10px 8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.03);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    label{ font-size:12px; color:rgba(255,255,255,0.82); letter-spacing:0.25px; }
    .val{ font-variant-numeric: tabular-nums; font-size:12px; color:rgba(255,255,255,0.72); }
    input[type="range"]{
      -webkit-appearance:none; appearance:none;
      width:100%; height:14px;
      background:transparent; outline:none;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:10px; border-radius:999px;
      background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.10);
    }
    input[type="range"]::-moz-range-track{
      height:10px; border-radius:999px;
      background: linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.10);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%;
      margin-top:-5px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.45));
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      border:1px solid rgba(0,0,0,0.35);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.45));
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      border:1px solid rgba(0,0,0,0.35);
    }
    .footer{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      color:rgba(255,255,255,0.55);
      font-size:11px;
      letter-spacing:0.2px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="panel" role="group" aria-label="Simulation controls">
    <div class="titleRow">
      <div class="title">3D Tri-Lights</div>
      <div class="hint">Course changes at intervals</div>
    </div>

    <div class="grid">
      <div class="control">
        <div class="row"><label for="speed">Spin Speed</label><div class="val" id="speedVal"></div></div>
        <input id="speed" type="range" min="0" max="1" step="0.001" value="0.38"/>
      </div>

      <div class="control">
        <div class="row"><label for="erratic">Erratic Motion</label><div class="val" id="erraticVal"></div></div>
        <input id="erratic" type="range" min="0" max="1" step="0.001" value="0.30"/>
      </div>

      <div class="control">
        <div class="row"><label for="hue">Color</label><div class="val" id="hueVal"></div></div>
        <input id="hue" type="range" min="0" max="360" step="0.1" value="200"/>
      </div>

      <div class="control">
        <div class="row"><label for="intensity">Light Intensity</label><div class="val" id="intensityVal"></div></div>
        <input id="intensity" type="range" min="0" max="1" step="0.001" value="0.65"/>
      </div>
    </div>

    <div class="footer">
      <span>3D via perspective projection (Canvas 2D)</span>
      <span>Formation stays rigid</span>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // Canvas (HiDPI aware)
  // -----------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // -----------------------------
  // UI
  // -----------------------------
  const elSpeed = document.getElementById('speed');
  const elErr   = document.getElementById('erratic');
  const elHue   = document.getElementById('hue');
  const elInt   = document.getElementById('intensity');

  const speedVal = document.getElementById('speedVal');
  const errVal   = document.getElementById('erraticVal');
  const hueVal   = document.getElementById('hueVal');
  const intVal   = document.getElementById('intensityVal');

  const params = {
    speed: +elSpeed.value,
    erratic: +elErr.value,
    hue: +elHue.value,
    intensity: +elInt.value,
  };

  function fmt(x,d=2){ return Number(x).toFixed(d); }
  function syncLabels(){
    const degPerSec = (params.speed ** 1.6) * 260;
    speedVal.textContent = fmt(degPerSec,0) + ' °/s';
    errVal.textContent   = fmt(params.erratic,2);
    hueVal.textContent   = fmt(params.hue,0) + '°';
    intVal.textContent   = fmt(params.intensity,2);
  }
  function bind(el,key){
    el.addEventListener('input', () => { params[key] = +el.value; syncLabels(); }, {passive:true});
  }
  bind(elSpeed,'speed'); bind(elErr,'erratic'); bind(elHue,'hue'); bind(elInt,'intensity');
  syncLabels();

  // -----------------------------
  // Math helpers (vectors + quaternions)
  // -----------------------------
  const TAU = Math.PI*2;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const mix = (a,b,t)=>a+(b-a)*t;
  const len3 = (v)=>Math.hypot(v.x,v.y,v.z);
  const norm3 = (v)=>{ const l=len3(v)||1; return {x:v.x/l,y:v.y/l,z:v.z/l}; };
  const dot3 = (a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const cross3=(a,b)=>({x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x});
  const add3=(a,b)=>({x:a.x+b.x,y:a.y+b.y,z:a.z+b.z});
  const mul3=(v,s)=>({x:v.x*s,y:v.y*s,z:v.z*s});

  // Quaternion: {w,x,y,z}, unit quaternion represents orientation
  const qNorm = (q)=>{
    const l=Math.hypot(q.w,q.x,q.y,q.z)||1;
    return {w:q.w/l,x:q.x/l,y:q.y/l,z:q.z/l};
  };
  const qMul = (a,b)=>({
    w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
    x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,
  });
  const qFromAxisAngle = (axis, angle)=>{
    const half = angle*0.5;
    const s = Math.sin(half);
    const a = norm3(axis);
    return qNorm({w:Math.cos(half), x:a.x*s, y:a.y*s, z:a.z*s});
  };
  const qRotateVec = (q,v)=>{
    // v' = q * (0,v) * q^-1 ; with unit q, q^-1 = conjugate
    const p = {w:0,x:v.x,y:v.y,z:v.z};
    const qc = {w:q.w,x:-q.x,y:-q.y,z:-q.z};
    const r = qMul(qMul(q,p),qc);
    return {x:r.x,y:r.y,z:r.z};
  };

  // Slerp for unit vectors on sphere (for rotation axis changes)
  function slerpDir(a,b,t){
    const an = norm3(a), bn = norm3(b);
    let c = clamp(dot3(an,bn), -1, 1);
    const ang = Math.acos(c);
    if (ang < 1e-5) return an;
    const s = Math.sin(ang);
    const w1 = Math.sin((1-t)*ang)/s;
    const w2 = Math.sin(t*ang)/s;
    return norm3(add3(mul3(an,w1), mul3(bn,w2)));
  }

  // Frame-rate independent smoothing (exponential approach)
  function expSlew(current, target, lambda, dt){
    const k = 1 - Math.exp(-lambda*dt);
    return current + (target-current)*k;
  }

  // Deterministic PRNG
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  const rand = mulberry32((Date.now() ^ 0x9E3779B9) >>> 0);
  const randRange = (a,b)=>a+(b-a)*rand();
  function randomUnitVector(){
    // Uniform-ish on sphere
    const u = rand()*2 - 1;        // z
    const t = rand()*TAU;          // angle
    const r = Math.sqrt(Math.max(0, 1-u*u));
    return {x:r*Math.cos(t), y:r*Math.sin(t), z:u};
  }

  // -----------------------------
  // Scene setup (rigid triangle in local space)
  // -----------------------------
  function equilateralTriangleVertices(side){
    // Triangle centered at origin, lying on XY plane
    // side s => circumradius R = s / sqrt(3)
    const R = side / Math.sqrt(3);
    return [
      {x: R, y: 0, z: 0},
      {x: R*Math.cos(TAU/3), y: R*Math.sin(TAU/3), z: 0},
      {x: R*Math.cos(2*TAU/3), y: R*Math.sin(2*TAU/3), z: 0},
    ];
  }

  // We'll derive side from screen size each frame (so it always fits nicely)
  let localVerts = equilateralTriangleVertices(1);

  // Orientation quaternion (starts as identity)
  let q = {w:1,x:0,y:0,z:0};

  // -----------------------------
  // "Course change" motion model (the core of your request)
  // -----------------------------
  // Instead of jittering every frame, we periodically pick *new targets* for:
  // - rotation axis (3D unit vector)
  // - angular speed multiplier
  // Then we smoothly steer toward those targets over time.
  //
  // As Erratic increases:
  // - course changes happen more often
  // - axis deviations are larger (more dramatic "course changes")
  // - steering responsiveness increases (but stays continuous)

  let axisCur = norm3({x: 0.2, y: 0.9, z: 0.35});
  let axisTgt = axisCur;

  let omegaMulCur = 1.0, omegaMulTgt = 1.0;

  let courseTimer = 0;
  let coursePeriod = 1.2; // will be mapped from erratic each frame

  function chooseNewCourse(err){
    // Deviation: low err -> small axis adjustment; high err -> larger reorientation
    const dev = 0.06 + 0.92*err; // [~0.06..0.98]
    const fresh = randomUnitVector();

    // Bias new axis near current axis for coherence; erratic controls how far we wander
    // (Slerp on sphere gives clean, intentional course changes.)
    axisTgt = slerpDir(axisCur, fresh, dev);

    // Speed multiplier can vary; keep bounded so it remains intentional
    const speedWander = 0.08 + 0.65*err;
    omegaMulTgt = clamp(1.0 + randRange(-1,1)*speedWander, 0.25, 2.2);
  }

  // -----------------------------
  // Rendering (glow & bloom in 2D)
  // -----------------------------
  function hsl(h,s,l,a=1){ return `hsla(${h.toFixed(2)}, ${s.toFixed(2)}%, ${l.toFixed(2)}%, ${a.toFixed(3)})`; }

  function fadeForTrails(intensity){
    // Brighter intensity -> longer bloom/trails (slower fade)
    const a = 0.11 + (1-intensity)*0.08;
    ctx.fillStyle = `rgba(0,0,0,${a.toFixed(3)})`;
    ctx.fillRect(0,0,W,H);
  }

  function vignette(){
    const g = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.05, W*0.5, H*0.55, Math.max(W,H)*0.70);
    g.addColorStop(0.00, 'rgba(0,0,0,0.00)');
    g.addColorStop(0.55, 'rgba(0,0,0,0.18)');
    g.addColorStop(1.00, 'rgba(0,0,0,0.55)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawGlow(x,y,r,hue,intensity, depthScale){
    // depthScale nudges glow size/alpha based on distance (3D cue)
    const ds = clamp(depthScale, 0.6, 1.6);

    const baseAlpha = (0.16 + 0.62*intensity) * (0.75 + 0.25*ds);
    const hotAlpha  = (0.22 + 0.70*intensity) * (0.70 + 0.30*ds);

    // Outer bloom
    {
      const R = r * (2.6 + 2.0*intensity) * ds;
      const g = ctx.createRadialGradient(x,y,0,x,y,R);
      g.addColorStop(0.00, hsl(hue,95,70,0.00));
      g.addColorStop(0.10, hsl(hue,95,70,baseAlpha*0.55));
      g.addColorStop(0.45, hsl(hue,95,55,baseAlpha*0.22));
      g.addColorStop(1.00, hsl(hue,95,45,0.00));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,R,0,TAU); ctx.fill();
    }

    // Mid glow
    {
      const R = r * (1.25 + 1.35*intensity) * ds;
      const g = ctx.createRadialGradient(x,y,0,x,y,R);
      g.addColorStop(0.00, hsl(hue,100,72,hotAlpha*0.25));
      g.addColorStop(0.20, hsl(hue,100,68,hotAlpha*0.60));
      g.addColorStop(0.60, hsl(hue,100,55,hotAlpha*0.22));
      g.addColorStop(1.00, hsl(hue,100,50,0.00));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,R,0,TAU); ctx.fill();
    }

    // Core
    {
      const R = r * (0.40 + 0.34*intensity) * ds;
      const g = ctx.createRadialGradient(x,y,0,x,y,R);
      g.addColorStop(0.00, hsl(hue,100,92,0.95));
      g.addColorStop(0.35, hsl(hue,100,80,0.65));
      g.addColorStop(1.00, hsl(hue,100,60,0.00));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,R,0,TAU); ctx.fill();
    }
  }

  // Perspective projection
  function project(v, camDist, fov){
    // camera looking toward origin from +Z, so we want (camDist - z) in denominator
    const zc = camDist - v.z;
    const s = fov / Math.max(0.001, zc);
    return { x: v.x * s, y: v.y * s, s, z: v.z };
  }

  // -----------------------------
  // Animation loop
  // -----------------------------
  let last = performance.now();
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  function frame(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    const cx = W*0.5;
    const cy = H*0.52;

    // Fit triangle to screen
    const baseSide = Math.min(W,H) * 0.44;
    localVerts = equilateralTriangleVertices(baseSide);

    // Base angular speed (rad/sec)
    const baseOmega = (params.speed ** 1.6) * 4.5;

    const e = params.erratic;

    // Course-change interval mapping: low err -> slow changes, high err -> frequent changes
    coursePeriod = mix(2.4, 0.20, e);

    courseTimer += dt;
    if (courseTimer >= coursePeriod){
      // Important: changes happen at intervals, not randomly every frame.
      courseTimer -= coursePeriod;
      chooseNewCourse(e);
    }

    // Steer toward targets smoothly (no teleporting):
    // Higher erratic -> faster steering (more decisive course changes).
    const steer = mix(2.2, 10.0, e);
    axisCur = slerpDir(axisCur, axisTgt, 1 - Math.exp(-steer*dt));
    omegaMulCur = expSlew(omegaMulCur, omegaMulTgt, steer*0.9, dt);

    // Integrate orientation using current axis and current angular speed:
    const omega = baseOmega * omegaMulCur;
    const dq = qFromAxisAngle(axisCur, omega * dt);
    q = qNorm(qMul(dq, q));

    // Subtle “breathing” hue to keep it alive while still unified
    const hue = (params.hue + 6.0*(0.15+0.85*e)*Math.sin(now*0.00035) + 360) % 360;

    // Camera: fixed but with a mild erratic-driven orbit for depth perception
    // (still coherent because it is smoothed and bounded)
    const camBase = Math.min(W,H) * 1.35;
    const camWob = (0.05 + 0.20*e) * Math.sin(now*0.00022);
    const camDist = camBase * (1.0 + camWob);
    const fov = Math.min(W,H) * 0.9;

    // Trails / fade
    fadeForTrails(params.intensity);

    // Rotate vertices into world space
    const world = localVerts.map(v => qRotateVec(q, v));

    // Project to screen
    const proj = world.map(v => {
      const p = project(v, camDist, fov);
      return {
        x: cx + p.x,
        y: cy + p.y,
        depthScale: p.s, // bigger when closer
        z: v.z
      };
    });

    // Draw faint edges (depth-cued)
    {
      const a = 0.02 + 0.09*params.intensity;
      ctx.lineWidth = 1.0;
      ctx.strokeStyle = hsl(hue, 90, 60, a);
      ctx.beginPath();
      ctx.moveTo(proj[0].x, proj[0].y);
      ctx.lineTo(proj[1].x, proj[1].y);
      ctx.lineTo(proj[2].x, proj[2].y);
      ctx.closePath();
      ctx.stroke();
    }

    // Sort lights back-to-front for nicer compositing when they overlap
    const idx = [0,1,2].sort((i,j)=>proj[i].z - proj[j].z);

    // Dot size (also depth-cued)
    const baseDot = Math.max(3.5, Math.min(7.5, Math.min(W,H)*0.008));
    const dotR = baseDot * (0.85 + 1.35*params.intensity);

    // Additive bloom pass
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const i of idx){
      drawGlow(proj[i].x, proj[i].y, dotR*4.0, hue, params.intensity, proj[i].depthScale);
    }
    ctx.restore();

    // Core highlight points (source-over) for crispness
    {
      const coreA = 0.55 + 0.35*params.intensity;
      ctx.fillStyle = hsl(hue, 100, 92, coreA);
      for (const i of idx){
        const r = dotR*0.55 * clamp(proj[i].depthScale, 0.75, 1.35);
        ctx.beginPath(); ctx.arc(proj[i].x, proj[i].y, r, 0, TAU); ctx.fill();
      }
    }

    // Subtle vignette
    vignette();

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
```
